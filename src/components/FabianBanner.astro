---
/**
 * FabianBanner.astro - Modal centrado para el agente de voz Fabian
 *
 * Modal ligero con preguntas provocativas + botón "Habla con Fabian".
 * Cierre fácil: X, overlay, ESC. No invasivo.
 *
 * - Aparece tras scroll 35% (solo si no fue cerrado antes en la sesión)
 * - Exit intent: reaparece si el ratón sale por arriba y el usuario no habló (máx 1 re-show)
 * - Click en botón o pregunta → cierra modal + activa widget ElevenLabs
 */

interface Props {
  translations: {
    title: string;
    subtitle: string;
    questions: string[];
    cta: string;
    collapsed: string;
  };
}

const { translations } = Astro.props;
---

<!-- Overlay - click para cerrar -->
<div id="fabian-overlay" class="fixed inset-0 z-[60] bg-black/50 hidden opacity-0 transition-opacity duration-300 cursor-pointer"></div>

<!-- Modal centrado -->
<div id="fabian-modal" class="fixed inset-0 z-[61] hidden items-center justify-center p-4 pointer-events-none">
  <div id="fabian-modal-content" class="relative bg-dark-surface border border-dark-border rounded-2xl shadow-2xl w-full max-w-sm pointer-events-auto opacity-0 scale-95 transition-all duration-300">

    <!-- X cerrar - grande y claro -->
    <button id="fabian-close" class="absolute -top-3 -right-3 w-8 h-8 flex items-center justify-center bg-dark-surface border border-dark-border rounded-full text-text-secondary hover:text-white hover:bg-white/10 transition-colors z-10 shadow-lg">
      <span class="material-symbols-outlined text-lg">close</span>
    </button>

    <div class="p-5 pb-4">
      <!-- Header -->
      <div class="flex items-center gap-2.5 mb-1">
        <span class="relative flex h-2.5 w-2.5">
          <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
          <span class="relative inline-flex rounded-full h-2.5 w-2.5 bg-green-500"></span>
        </span>
        <h3 class="text-base font-bold text-white">{translations.title}</h3>
      </div>
      <p class="text-xs text-text-secondary mb-4 ml-5">{translations.subtitle}</p>

      <!-- Preguntas -->
      <ul class="space-y-2 mb-5">
        {translations.questions.map((question) => (
          <li class="fabian-q flex items-start gap-2.5 py-2 px-3 rounded-lg cursor-pointer hover:bg-white/5 transition-colors group">
            <span class="material-symbols-outlined text-primary-orange text-base mt-0.5 flex-shrink-0">chat_bubble</span>
            <span class="text-sm text-white/80 leading-snug group-hover:text-white transition-colors">{question}</span>
          </li>
        ))}
      </ul>

      <!-- Botón principal -->
      <button id="fabian-talk-btn" class="fabian-cta w-full py-3 px-4 bg-gradient-to-r from-primary-orange to-primary-red text-white font-semibold rounded-xl text-sm flex items-center justify-center gap-2 hover:shadow-lg hover:shadow-primary-orange/25 active:scale-[0.98] transition-all">
        <span class="material-symbols-outlined text-xl">mic</span>
        {translations.cta}
      </button>
    </div>
  </div>
</div>

<script>
  const STORAGE_KEY = 'lowis_fabian_dismissed';
  const SCROLL_THRESHOLD = 0.35;

  function initFabianModal() {
    const overlay = document.getElementById('fabian-overlay');
    const modal = document.getElementById('fabian-modal');
    const content = document.getElementById('fabian-modal-content');
    const closeBtn = document.getElementById('fabian-close');
    const talkBtn = document.getElementById('fabian-talk-btn');
    const questions = document.querySelectorAll('.fabian-q');

    if (!overlay || !modal || !content) return;

    let isVisible = false;
    let talked = false;       // true if user clicked to talk
    let dismissCount = 0;     // how many times dismissed
    const alreadyDismissed = sessionStorage.getItem(STORAGE_KEY);

    function show() {
      if (isVisible) return;
      isVisible = true;
      overlay.classList.remove('hidden');
      modal.classList.remove('hidden');
      modal.classList.add('flex');
      requestAnimationFrame(() => {
        overlay.style.opacity = '1';
        content.style.opacity = '1';
        content.style.transform = 'scale(1)';
      });
    }

    function close() {
      if (!isVisible) return;
      overlay.style.opacity = '0';
      content.style.opacity = '0';
      content.style.transform = 'scale(0.95)';
      isVisible = false;
      dismissCount++;
      sessionStorage.setItem(STORAGE_KEY, '1');
      setTimeout(() => {
        overlay.classList.add('hidden');
        modal.classList.add('hidden');
        modal.classList.remove('flex');
      }, 250);
    }

    function activateWidget() {
      // ElevenLabs widget has 2 states inside its Shadow DOM:
      // 1. Collapsed: a button with class *_minimize_* → click to expand
      // 2. Expanded: a "Start a call" button (primary, not minimize/secondary)
      // We need to expand first, then click "Start a call".
      const widget = document.querySelector('elevenlabs-convai') as HTMLElement;
      if (!widget) return;

      let attempts = 0;
      const maxAttempts = 25;
      let expanded = false;

      const interval = setInterval(() => {
        attempts++;
        const root = widget.shadowRoot;
        if (!root) {
          if (attempts >= maxAttempts) clearInterval(interval);
          return;
        }

        // Check if widget is already expanded
        const wrapper = root.querySelector('div[class*="_wrapper_"]');
        const isOpen = wrapper?.className.includes('_open_');

        if (!isOpen && !expanded) {
          // Step 1: Click the minimize/expand button
          const expandBtn = root.querySelector('button[class*="_minimize_"]') as HTMLElement;
          if (expandBtn) {
            expandBtn.click();
            expanded = true;
          }
        } else if (isOpen) {
          // Step 2: Click the "Start a call" primary button
          const buttons = root.querySelectorAll('button[class*="_btn_"]');
          for (const btn of buttons) {
            const cls = btn.className;
            if (cls.includes('_minimize_') || cls.includes('_secondary_') || cls.includes('_iconBtn_')) continue;
            (btn as HTMLElement).click();
            clearInterval(interval);
            return;
          }
        }

        if (attempts >= maxAttempts) clearInterval(interval);
      }, 250);
    }

    function closeAndTalk() {
      talked = true;
      close();
      // Give modal time to close, then activate widget
      setTimeout(activateWidget, 400);
    }

    // Cerrar: X, overlay, ESC
    closeBtn?.addEventListener('click', close);
    overlay.addEventListener('click', close);
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && isVisible) close();
    });

    // Botón principal → hablar
    talkBtn?.addEventListener('click', closeAndTalk);

    // Click en pregunta → hablar
    questions.forEach(q => q.addEventListener('click', closeAndTalk));

    // Scroll trigger - show on first visit (not dismissed this session)
    let scrollTriggered = false;
    let ticking = false;
    function onScroll() {
      if (scrollTriggered || isVisible || alreadyDismissed) return;
      const total = document.documentElement.scrollHeight - window.innerHeight;
      if (total > 0 && (window.scrollY / total) >= SCROLL_THRESHOLD) {
        scrollTriggered = true;
        show();
      }
    }

    window.addEventListener('scroll', () => {
      if (!ticking) {
        requestAnimationFrame(() => { onScroll(); ticking = false; });
        ticking = true;
      }
    }, { passive: true });

    // Exit intent - mouse leaves viewport from top (towards close/back)
    // Works even if scroll-trigger was blocked by sessionStorage
    document.addEventListener('mouseout', (e: MouseEvent) => {
      // Only trigger when mouse actually leaves the viewport from the top edge
      if (!e.relatedTarget && e.clientY <= 0) {
        if (talked || isVisible || dismissCount > 1) return;
        show();
      }
    });

    onScroll();
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initFabianModal);
  } else {
    initFabianModal();
  }
</script>

<style>
  .fabian-cta {
    position: relative;
    overflow: hidden;
  }
  .fabian-cta::after {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.15), transparent);
    animation: ctaShine 3s ease-in-out infinite;
  }
  @keyframes ctaShine {
    0% { left: -100%; }
    50%, 100% { left: 100%; }
  }
</style>
